<!DOCTYPE html>
	<html lang="en" dir="ltr">
		<head>
			<title>Mobile development guide</title>
			<meta charset = "utf-8">
			<meta name="viewport" content="width=device-width, initial-scale=1">
			<link rel="stylesheet" href="css/bootstrap.min.css">
			<link rel="stylesheet" href="css/bootstrap-grid.css">
			<link rel="stylesheet" href="indexCss.css">
			<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.3/jquery.min.js"></script>
			<script src="js/bootstrap.min.js"></script>
		</head>
		<body>
			<nav class="navbar navbar-expand-sm navbar-expand-md bg-light navbar-light">
				<ul class="navbar-nav">
					<li class="nav-item active">
						<a class="nav-link" href="mobileAssign.html">Logic layer</a>
					</li>
					<li class="nav-item">
						<a class="nav-link" href="viewLayer.html">View layer</a>
					</li>
					<li class="nav-item">
						<a class="nav-link" href="androidStudioID.html">Android Studio ID</a>
					</li>
				</ul>
			</nav>
			<div class="container">
				<h1>Mobile Application Development Fundamental</h1>
				<div class="parentBox">
					<h2>General</h2>
					<div class="box">
						<h3>View</h3>
						<p>
							<pre>
int viewID = view.getId();
							</pre>
						</p>
					</div>
					<div class = "box">
						<h3>TextView/EditText</h3>
						<p>
							Common public method: 
							<pre>
private TextView viewText = (TextView)findViewById(R.id.textMain); //binding
viewText.getText().toString(); //get the value of textView/editText
viewText.setText("abc"); //set the value of textView
viewText.setTextColor(colorId); //set the text colour of textView
viewText.getCurrentTextColor(); //get the current text colour of textView 
viewText.setVisibility(View.VISIBLE); //set visibility of textView to visible
viewText.setOnLongClickListener();
viewText.setOnClickListener(); //add onclick method for the textView if the class 
//implements View.OnClickListener
							</pre>
						</p>
					</div>
					<div class = "box">
						<h3>Intent</h3>
						<p>
							Common public method:
							<pre>
Intent intent = new Intent(this, secondActivity.class); //explicit intent constructor
new Intent(Intent.ACTION_VIEW, uri); //implicit intent constructor
intent.putExtra(EXTRA_KEY, message); //send data
startActivity(intent); //open another activity
startActivityForResult(intent, TEXT_REQUEST); //Open another activity to get result 
Intent intent = getIntent(); 
intent.getStringExtra(MainActivity.EXTRA_KEY); //get message
finish(); //close activity
							</pre>
						</p>
					</div>
					<div class = "box">
						<h3>Uri</h3>
						<p>
							Common public method:
							<pre>
Uri webpg = Uri.parse(url); //Parse string url to Uri object 
Uri location = Uri.parse("geo:0,0?q=" + loc); //Parse string location to Uri object 
							</pre>
						</p>
					</div>
					<div class = "box">
						<h3>Toast</h3>
						<p>
							Common public method: 
							<pre>
Toast.makeText(this, message, Toast.LENGTH_SHORT).show(); //show toast
							</pre>
						</p>
					</div>
					<div class = "box">
						<h3>Random</h3>
						<p>
							Common public methods:
							<pre>
Random random = new Random(); //Random object constructor
int num = random.nextInt(20); //Get the random number between 0 and 19
							</pre>
						</p>
					</div>
					<div class = "box">
						<h3>Resource</h3>
						<p>
							When app is compiled, Android convert resource xml file into resources with integer Id, there are
							separate Id for both the names and the values of the resource
							<pre>
int colorResourceName = getResources().getIdentifier(colorName,
"color", getApplicationContext().getPackageName()); // get the resource id (integer) for colorName
//get the integer ID for actual value using resource id for colorName
int colorRes = ContextCompat.getColor(this, colorResourceName);

//another way to get color without resource name 
int colorRes = ContextCompat,getColor(this, R.color.colorName);

mHelloTextView.setTextColor(colorRes); // set colour of textView with resource id of actual value

//get string
String str = getString(R.string.hello);

//get String array
String[] planets = getResources().getStringArray(R.array.planets_array);

//get drawable array
TypedArray imageResources = getResources().obtainTypedArray(R.array.sports_images);
							</pre>
						</p>
					</div>
				</div>
				<div class="parentBox">
					<h2>Activity</h2>
					<div class="box">
						<h3>Create child activity</h3>
						<p>
							Parent-child relationship enable Android to add nav hint (left facing arrow in title) for
							each child activity to navigate from child screen back to parent screen.<br>
							In Manifest.xml file, coding:
							<pre>
<mark>Whenever create an activity, must tell Manifest.xml the existence of this activity
</mark>							
&lt;activity android:name=".SecondActivity"
	android:label="Activity2name"
	android:parentActivityName=".MainActivity"&gt;
	&lt;meta-data
	android:name="android.support.PARENT_ACTIVITY"
	android:value="com.example.android.twoactivities.MainActivity"/&gt;
&lt;/activity&gt;			
							</pre>
						</p>
					</div>
					<div class="box">
						<h3>Start one activity from another activity [only]</h3>
						<p>
							Start another activity with no expectation of getting any result from the activity<br>
							In button:onClick method (when user click on button, open second activity) coding:
							<pre>
Intent intent = new Intent(this, SecondActivity.class);
startActivity(intent);
							</pre>
						</p>
					</div>
					<div class="box">
						<h3>Start another activity and pass data to the activity</h3>
						<p>
							In Main Activity coding:
							<pre>
private static final String LOG_TAG = MainActivity.class.getSimpleName();
public static final String EXTRA_MESSAGE = "com.example.android.twoactivities.extra.MESSAGE";
private EditText mMessageEditText; 

<mark>In onCreate():</mark>
mMessageEditText = (EditText) findViewById(R.id.editText_main);

<mark>In button:onClick method:</mark>
Log.d(LOG_TAG, "Button clicked!");
Intent intent = new Intent(this, SecondActivity.class);
String message = mMessageEditText.getText().toString(); 
intent.putExtra(EXTRA_MESSAGE, message);
startActivity(intent);
							</pre>
							<p>
							In Another activity coding:
							</p>
													
<pre><mark>In onCreate():</mark>
Intent intent = getIntent();
String message = intent.getStringExtra(MainActivity.EXTRA_MESSAGE); 
TextView textView = (TextView) findViewById(R.id.text_message);
textView.setText(message);
							</pre>
						</p>
					</div>
					<div class="box">
						<h3>Start another Activity and get response from the activity</h3>
						<p>
							In Another Activity, coding:												
<pre>public static final String EXTRA_REPLY ="com.example.android.twoactivities.extra.REPLY";
private EditText mReply;	

<mark>In button:onClick method:</mark>
String reply = mReply.getText().toString();
Intent replyIntent = new Intent();
replyIntent.putExtra(EXTRA_REPLY, reply);
setResult(RESULT_OK, replyIntent);
finish();	
							</pre>
							<p>
							In Main Activity, coding:
							</p>							
<pre>public static final int TEXT_REQUEST = 1;
private TextView mReplyHeadTextView;
private TextView mReplyTextView;

<mark>In onCreate()</mark>
mReplyHeadTextView = (TextView) findViewById(R.id.text_header_reply);
mReplyTextView = (TextView) findViewById(R.id.text_message_reply);

<mark>In button: onClick method that start another activity</mark>
Log.d(LOG_TAG, "Button clicked!");
Intent intent = new Intent(this, SecondActivity.class);
startActivityForResult(intent, TEXT_REQUEST);

public void onActivityResult(int requestCode, int resultCode, Intent data) {
	super.onActivityResult(requestCode, resultCode, data);
	if (requestCode == TEXT_REQUEST) {
		if (resultCode == RESULT_OK) {
			String reply = data.getStringExtra(SecondActivity.EXTRA_REPLY);
			mReplyTextView.setText(reply);
		}
	}
}
							</pre>
						</p>
					</div>
					<div class="box">
						<h3>Save Activity data from onDestroy() (onSaveInstanceState)</h3>
						<p>
							Rotated the device result in onDestroy() which current activity being destroyed and recreated.
							Keep data in activity when onDestroy by implement onSaveInstanceState()<br>
							In Main Activity, coding:
													
<pre><mark>In onCreate()</mark>
// Initialize all the view variables.
mReplyTextView = (TextView) findViewById(R.id.text_message_reply);
// Restore the saved state. See onSaveInstanceState() for what gets saved.
if (savedInstanceState != null) {
	savedInstanceState.getBoolean("reply_visible");
	mReplyTextView.setText(savedInstanceState.getString("reply_text"));
}

@Override
public void onSaveInstanceState(Bundle outState) {
	super.onSaveInstanceState(outState);
	outState.putBoolean("reply_visible", true);
	outState.putString("reply_text", mReplyTextView.getText().toString());
}
						</pre>
						</p>
					</div>
					<div class="box">
						<h3>Activate other activities/app to perform specific action (Implicit intent)</h3>
						<p>
							Main activity pass data to specific app installed on the device (e.g. browser) to perform 
							specific action (e.g. visit website)
							<br>In Main Activity, coding:									
<pre>private EditText mWebsiteEditText;

<mark>In onCreate()</mark>
mWebsiteEditText = (EditText) findViewById(R.id.website_edittext);

<mark>In button:onClick method</mark>
String url = mWebsiteEditText.getText().toString();
Uri webpage = Uri.parse(url);
//Uri addressUri = Uri.parse("geo:0,0?q=" + loc);
Intent intent = new Intent(Intent.ACTION_VIEW, webpage);
if (intent.resolveActivity(getPackageManager()) != null) {
	startActivity(intent);
} else {
	Log.d("ImplicitIntents", "Can't handle this intent!");
}		
							</pre>
						</p>
					</div>
					<div class="box">
						<h3>Receive implicit intents to perform action</h3>
						<p>
							In Manifest.xml file, coding:
							<pre>
<mark>Add under intent-filter</mark>
&lt;intent-filter&gt;
&lt;action android:name="android.intent.action.VIEW" /&gt;
&lt;category android:name="android.intent.category.DEFAULT" /&gt;
&lt;category android:name="android.intent.category.BROWSABLE" /&gt;
&lt;data android:scheme="http"
android:host="developer.android.com" /&gt;
&lt;/intent-filter&gt;
							</pre>
							<p>
							In Main Activity, coding:
							</p>						
<pre><mark>In onCreate()</mark>
Intent intent = getIntent();
Uri uri = intent.getData();
if (uri != null) {
	String uri_string = "URI: " + uri.toString();
}
<mark>Do some action on uri_string</mark>
							</pre>
						</p>
					</div>
				</div>
				<div class="parentBox">
					<h2>Component</h2>
					<div class="box">
						<h3>Spinner</h3>
						<p>
							Is an adapter view whose children (item) detemined by an Adapter 
							(can bridge between Spinner and data (string-array in string.xml)).
							Provide quick way to select one value from a set when not neccessary to show all option
							<br>In Main Activity, coding:
							<pre>
<mark>Main Activity class implement interface</mark>
implements AdapterView.OnItemSelectedListener

private static final String TAG = MainActivity.class.getSimpleName();
private String mSpinnerLabel = "";

<mark>In onCreate()</mark>
Spinner spinner = (Spinner) findViewById(R.id.label_spinner);
if (spinner != null) {
	spinner.setOnItemSelectedListener(this);
}
ArrayAdapter&lt;CharSequence&gt; adapter = ArrayAdapter.createFromResource(this,
R.array.labels_array, android.R.layout.simple_spinner_item);
adapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item);
if (spinner != null) {
    spinner.setAdapter(adapter);
}

@Override
public void onItemSelected(AdapterView&lt;?&gt; adapterView, View view, int pos, long id) {
    mSpinnerLabel = adapterView.getItemAtPosition(pos).toString();
    //showText(view); showText will make use of mSpinnerLabel(var stored Spinner item selected by user)
}
	
@Override
public void onNothingSelected(AdapterView&lt;?&gt; adapterView) {
    Log.d(TAG, "onNothingSelected: ");
}

<mark>In case use of different spinner, One adapter used for one spinner, retrieved selected item 
of different spinner in onItemSelected
@Override
public void onItemSelected(AdapterView&lt;?&gt; adapterView, View view, int pos, long id) {
	switch(adapterView.getId()){
		case R.id.label_spinner//spinnerId 
			mSpinnerLabel = adapterView.getItemAtPosition(pos).toString();
			break;}//Implementation code
}</mark>
							</pre>
						</p>
					</div>	
					<div class="box">
						<h3>Provide dialog for ALERT to require user decision</h3>
						<p>
							In main Activity, coding:
							<pre>
<mark>In button:onClick method</mark>
AlertDialog.Builder myAlertBuilder = new AlertDialog.Builder(MainActivity.this);
myAlertBuilder.setTitle("Alert");
myAlertBuilder.setMessage("Click OK to continue, or Cancel to stop:");
myAlertBuilder.setPositiveButton("OK", new DialogInterface.OnClickListener() {
	public void onClick(DialogInterface dialog, int which) {
	Toast.makeText(getApplicationContext(), "Pressed OK",
	Toast.LENGTH_SHORT).show(); //implementation code
	}
});
myAlertBuilder.setNegativeButton("Cancel", new
DialogInterface.OnClickListener() {
public void onClick(DialogInterface dialog, int which) {
// User cancelled the dialog.
Toast.makeText(getApplicationContext(), "Pressed Cancel",
Toast.LENGTH_SHORT).show();//implementation code
}
});
myAlertBuilder.show();
							</pre>
						</p>
					</div>
					<div class="box">
						<h3>DatePicker & TimePicker</h3>
						<p>
							Ready to use dialogs for picking time/date using fragment (mini activity)
							<br>Create Blank Fragment for Date:
							<pre>
<mark>The fragment class extends superclass and implement interface</mark>
extends DialogFragment implements DatePickerDialog.OnDateSetListener

<mark>Remove empty public constructor</mark>

<mark>Replace onCreateview() with onCreateDialog()</mark>
@NonNull
@Override
public Dialog onCreateDialog(Bundle savedInstanceState) {
final Calendar c = Calendar.getInstance();
int year = c.get(Calendar.YEAR);
int month = c.get(Calendar.MONTH);
int day = c.get(Calendar.DAY_OF_MONTH);
return new DatePickerDialog(getActivity(), this, year, month, day);
}

public void onDateSet(DatePicker view, int year, int month, int day) {
	MainActivity activity = (MainActivity) getActivity();
	activity.processDatePickerResult(year, month, day);
}
							</pre>
							<p>
							Create Blank Fragment for time
							</p>							
<pre><mark>The fragment class extends superclass and implement interface</mark>
extends DialogFragment implements TimePickerDialog.OnTimeSetListener

<mark>Remove empty public constructor</mark>

<mark>Replace onCreateview() with onCreateDialog()</mark>
@NonNull
@Override
public Dialog onCreateDialog(Bundle savedInstanceState) {
final Calendar c = Calendar.getInstance();
int hour = c.get(Calendar.HOUR_OF_DAY);
int minute = c.get(Calendar.MINUTE);
return new TimePickerDialog(getActivity(), this, hour, minute,
DateFormat.is24HourFormat(getActivity()));
}

public void onTimeSet(TimePicker view, int hourOfDay, int minute) {
	MainActivity activity = (MainActivity) getActivity();
	activity.processTimePickerResult(hourOfDay, minute);
}
							</pre>
							<p>
							In main Activity, coding:
							</p>							
<pre><mark> Button:onClick method for date</mark>
DialogFragment newFragment = new DatePickerFragment();
newFragment.show(getSupportFragmentManager(), "datePicker");

<mark> Button:onClick method for time</marK>
DialogFragment newFragment = new TimePickerFragment();
newFragment.show(getSupportFragmentManager(), "timePicker");

public void processDatePickerResult(int year, int month, int day) {
	//implementation code (This method can get date from fragment)
	String month_string = Integer.toString(month + 1);
	String day_string = Integer.toString(day);
	String year_string = Integer.toString(year);
	String dateMessage = (month_string + "/" + day_string + "/" + year_string);
	Toast.makeText(this, "Date: " + dateMessage,
	Toast.LENGTH_SHORT).show();
}

public void processTimePickerResult(int hourOfDay, int minute) {
String hour_string = Integer.toString(hourOfDay);
String minute_string = Integer.toString(minute);
String timeMessage = (hour_string + ":" + minute_string);
Toast.makeText(this, "Time: " + timeMessage,
Toast.LENGTH_SHORT).show();
}
							</pre>
						</p>
					</div>
					<div class="box">
						<h3>Radio Button</h3>
						<p>
							Allow user to select only one item, use it if need to display all available option side by side
							<br>In main Activity, coding:
							<pre>
private static final String TAG_ACTIVITY = OrderActivity.class.getSimpleName();

<mark>In radioButton:onclick method</mark>
boolean checked = ((RadioButton) view).isChecked();
switch(view.getId()) {
	case R.id.sameday:
		if (checked)
			//implementation code
			displayToast(getString(R.string.chosen) +
			getString(R.string.same_day_messenger_service));
			break;
	case R.id.nextday:
		if (checked)
			displayToast(getString(R.string.chosen) +
getString(R.string.next_day_ground_delivery));
			break;
	case R.id.pickup:
		if (checked)
			displayToast(getString(R.string.chosen) + getString(R.string.pick_up));
			break;
	default:
		Log.d(TAG_ACTIVITY, getString(R.string.nothing_clicked));
		break;
}
							</pre>
						</p>
					</div>
					<div class="box">
						<h3>Recycler View</h3>
						<p>
							Resource efficient way to display list compared to Scrollable list, recommended to use when displaying long list.
							Reuse created viewholder object and bind to data. 
							<br>Add dependencies (com.android.support:recyclerview and com.android.support:design:)
							<br>Create new java class:
							<pre>
<mark>The class extends superclass</mark>
extends RecyclerView.Adapter&lt;WordListAdapter.WordViewHolder&gt;

private final LinkedList&lt;String&gt; mWordList;
private final LayoutInflater mInflater;

<mark>Create innerclass viewHolder extends superclass and implement interface</mark>
extends RecyclerView.ViewHolder implements View.OnClickListener

<mark>In innerclass</mark>
public final TextView wordItemView;
final WordListAdapter mAdapter;
public WordViewHolder(View itemView, WordListAdapter adapter) {
    super(itemView);
    wordItemView = (TextView) itemView.findViewById(R.id.word);
    this.mAdapter = adapter;
    itemView.setOnClickListener(this);
}

 @Override
public void onClick(View v) {
	//Implementation code after list item click
    wordItemView.setText ("Clicked! "+ wordItemView.getText());
}

<mark>Outside innerclass</mark>
 public WordListAdapter(Context context, LinkedList&lt;String&gt; wordList) {
    mInflater = LayoutInflater.from(context);
    this.mWordList = wordList;
}

@Override
public WordViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {
    View mItemView = mInflater.inflate(R.layout.wordlist_item, parent, false);
    return new WordViewHolder(mItemView, this);
}

@Override
public void onBindViewHolder(WordViewHolder holder, int position) {
    String mCurrent = mWordList.get(position);
    holder.wordItemView.setText(mCurrent);
}

@Override
public int getItemCount() {
    return mWordList.size();
}
							</pre>
							<p>
							In main Activity, coding:		
							</p>
<pre>private RecyclerView mRecyclerView;
private WordListAdapter mAdapter;
private final LinkedList&lt;String&gt; mWordList = new LinkedList&lt;&gt;();

<mark>In onCreate()</mark>
for (int i = 0; i &lt; 20; i++) {
    mWordList.addLast("Word " + i);//data
}
mRecyclerView = (RecyclerView) findViewById(R.id.recyclerview);
mAdapter = new WordListAdapter(this, mWordList);
mRecyclerView.setAdapter(mAdapter);
mRecyclerView.setLayoutManager(new LinearLayoutManager(this));
							</pre>
						</p>
					</div>
					<div class="box">
						<h3>FAB</h3>
						<p>
							In main Activity, coding:
							<pre>
<mark>In onCreate()</mark>
FloatingActionButton fab = (FloatingActionButton) findViewById(R.id.fab);
        fab.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View view) {
                int wordListSize = mWordList.size();
                mWordList.addLast("+ Word " + wordListSize);
                mRecyclerView.getAdapter().notifyItemInserted(wordListSize);
                mRecyclerView.smoothScrollToPosition(wordListSize);
            }
        });
							</pre>
						</p>
					</div>
					<div class="box">
						<h3>Option menu</h3>
						<p>
							In Main Activity, coding
							<pre>
@Override
public boolean onCreateOptionsMenu(Menu menu) {
// Inflate the menu; this adds items to the action bar if it is present.
	getMenuInflater().inflate(R.menu.menu_main, menu);
    return true;
}

@Override
public boolean onOptionsItemSelected(MenuItem item) {
    switch (item.getItemId()) {
        case R.id.action_order:
            Intent intent = new Intent(MainActivity.this,
                    OrderActivity.class);
            intent.putExtra(EXTRA_MESSAGE, mOrderMessage);
            startActivity(intent);
            return true;
        case R.id.action_status:
            displayToast(getString(R.string.action_status_message));
            return true;
        case R.id.action_favorites:
            displayToast(getString(R.string.action_favorites_message));
            return true;
        case R.id.action_contact:
            displayToast(getString(R.string.action_contact_message));
            return true;
        default:
            // Do nothing
    }
    return super.onOptionsItemSelected(item);
}
							</pre>
						</p>
					</div>
					<div class="box">
						<h3>SharedPreferences</h3>
						<p>
							Allow to store small amounts of data as key/value in file on device.
							Shared preferences persist even app stop or if device reboot.
							<br>In main Activity, coding:
							<pre>
<mark>Do not use the SharedPreferences and SaveInstanceState to save data at the same time</mark>
// Key for current count
private final String COUNT_KEY = "count";
// Key for current color
private final String COLOR_KEY = "color";
private SharedPreferences mPreferences;
private String sharedPrefFile = 
   "com.example.android.hellosharedprefs";
   
<mark>In onCreate()</mark>
mPreferences = getSharedPreferences(sharedPrefFile, MODE_PRIVATE);
// Restore preferences
mCount = mPreferences.getInt(COUNT_KEY, 0);
mShowCountTextView.setText(String.format("%s", mCount));
mColor = mPreferences.getInt(COLOR_KEY, mColor);
mShowCountTextView.setBackgroundColor(mColor);

<mark>Outside onCreate()</mark>
 public void reset(View view) {
        // Reset count
        mCount = 0;
        mShowCountTextView.setText(String.format("%s", mCount));

        // Reset color
        mColor = ContextCompat.getColor(this,
                R.color.default_background);
        mShowCountTextView.setBackgroundColor(mColor);

        // Clear preferences
        SharedPreferences.Editor preferencesEditor = mPreferences.edit();
        preferencesEditor.clear();
        preferencesEditor.apply();
    }

    /**
     * Callback for activity pause.  Shared preferences are saved here.
     */
    @Override
    protected void onPause() {
        super.onPause();

        SharedPreferences.Editor preferencesEditor = mPreferences.edit();
        preferencesEditor.putInt(COUNT_KEY, mCount);
        preferencesEditor.putInt(COLOR_KEY, mColor);
        preferencesEditor.apply();
    }
							</pre>
						</p>
					</div>
					<div class="box">
						<h3>AsyncTask</h3>
						<p>
							Able to move intensive processing onto separate thread so UI thread is not blocked (can result in
							app not responds to user input). Cannot update UI after onDestroy();
							<br>Create java class SimpleAsyncTask, coding:
							<pre>
<mark>extends superclass</mark>
extends AsyncTask&lt;Void,Void, String&gt;

private WeakReference&lt;TextView&gt; mTextView;
SimpleAsyncTask(TextView tv) {
            mTextView = new WeakReference&lt;&gt;(tv);
    }

 @Override
protected String doInBackground(Void... voids) {
//implementation code, return string 
return "Awake at last after sleeping for " + s + " milliseconds!";
    }
	
protected void onPostExecute(String result) {
        mTextView.get().setText(result);
}
							</pre>
							<p>
							In main Activity, coding:
							</p>
							<pre>
<mark>In onCreate()</mark>
// Restore TextView if there is a savedInstanceState bundle.
        if (savedInstanceState != null) {
            mTextView.setText(savedInstanceState.getString(TEXT_STATE));
        }
		
<mark>Outside onCreate()</mark>
 public void startTask(View view) {
        mTextView.setText(R.string.napping);

        // Start the AsyncTask.
        // The AsyncTask has a callback that will update the text view.
        new SimpleAsyncTask(mTextView).execute();
    }
	
@Override
    protected void onSaveInstanceState(Bundle outState) {
        super.onSaveInstanceState(outState);
        outState.putString(TEXT_STATE, mTextView.getText().toString());
    }
							</pre>
						</p>
					</div>
					<div class="box">
						<h3>AsyncTask2 (use Google API for book search)</h3>
						<p>
							In main Activity, coding:
							<pre>
<mark>Use InputMethodManager method hideSoftInputFromWindow to hides keyboard when user taps the button</mark>
<mark>Use ConnectivityManager to check the state of network connection & check if user entered query string.
If both ok then only query the Books API, otherwise display error message</mark>
<mark>Above coding for User experience purposes</mark>
<mark>connect Internet, query API, get JSON response and show result, all doing in Async Task by passing 
2 textview for onPostExecute and queryString for doInBackground</mark>
public void searchBooks(View view) {
        String queryString = mBookInput.getText().toString();

        InputMethodManager inputManager = (InputMethodManager)
                getSystemService(Context.INPUT_METHOD_SERVICE);
        if (inputManager != null ) {
            inputManager.hideSoftInputFromWindow(view.getWindowToken(),
                    InputMethodManager.HIDE_NOT_ALWAYS);
        }

        ConnectivityManager connMgr = (ConnectivityManager)
                getSystemService(Context.CONNECTIVITY_SERVICE);
        NetworkInfo networkInfo = null;
        if (connMgr != null) {
            networkInfo = connMgr.getActiveNetworkInfo();
        }

        if (networkInfo != null && networkInfo.isConnected()
                && queryString.length() != 0) {
            new FetchBook(mTitleText, mAuthorText).execute(queryString);
            mAuthorText.setText("");
            mTitleText.setText(R.string.loading);
        } else {
            if (queryString.length() == 0) {
                mAuthorText.setText("");
                mTitleText.setText(R.string.no_search_term);
            } else {
                mAuthorText.setText("");
                mTitleText.setText(R.string.no_network);
            }
        }
    }
							</pre>
							<p>
							Create FetchBook java, coding:
							<pre>
<mark>Extends superclass | Note: String - query, Void - no progress indicator, and String - JSON response</mark>
 extends AsyncTask&lt;String, Void, String&gt;
 
<mark>In doInBackground, pass query string to getBookInfo() and return JSON response string to onPostExecute</mark>
<mark>In onPostExecute, create JSONObject with JSON response string and create JSONArray to obtain the JSON 
array of "items". Loop through array to check each book for title and author, if found escape loop 
display book title and author || Note: Because the references to the TextView objects are WeakReference 
objects, dereference using textView.get()</mark>
private WeakReference&lt;TextView&gt; mTitleText;
private WeakReference&lt;TextView&gt; mAuthorText;

    public FetchBook(TextView titleText, TextView authorText) {
        this.mTitleText = new WeakReference&lt;&gt;(titleText);
        this.mAuthorText = new WeakReference&lt;&gt;(authorText);
    }

    @Override
    protected String doInBackground(String... strings) {
        return NetworkUtils.getBookInfo(strings[0]);
    }
	
	@Override
    protected void onPostExecute(String s) {
        super.onPostExecute(s);
        try {
            JSONObject jsonObject = new JSONObject(s);
            JSONArray itemsArray = jsonObject.getJSONArray("items");
            int i = 0;
            String title = null;
            String authors = null;
            while (i &lt; itemsArray.length() &&
                    (authors == null && title == null)) {
                JSONObject book = itemsArray.getJSONObject(i);
                JSONObject volumeInfo = book.getJSONObject("volumeInfo");
                try {
                    title = volumeInfo.getString("title");
                    authors = volumeInfo.getString("authors");
                } catch (Exception e) {
                    e.printStackTrace();
                }
                i++;
            }
            if (title != null && authors != null) {
                mTitleText.get().setText(title);
                mAuthorText.get().setText(authors);
            } else {
                mTitleText.get().setText(R.string.no_results);
                mAuthorText.get().setText("");
            }
        } catch (Exception e) {
            mTitleText.get().setText(R.string.no_results);
            mAuthorText.get().setText("");
        }
    }
							</pre>
							</p>
							<p>
							Create NetworkUtils to return JSON response string, coding:
							<pre>
<mark>Form HTTP request (according in Books API) by parsing queryParameter into Uri object,
then convert Uri to Url. Open url connection, send request using GET method,
use HttpUrlConnection to obtain JSON response from web. Load the response in
buffered reader and loop to read and store in string builder then return as str</mark>
private static final String LOG_TAG = NetworkUtils.class.getSimpleName();
private static final String BOOK_BASE_URL =  "https://www.googleapis.com/books/v1/volumes?";
private static final String QUERY_PARAM = "q";
private static final String MAX_RESULTS = "maxResults";
private static final String PRINT_TYPE = "printType";

static String getBookInfo(String queryString){
        HttpURLConnection urlConnection = null;
        BufferedReader reader = null;
        String bookJSONString = null;
        try {
            Uri builtURI = Uri.parse(BOOK_BASE_URL).buildUpon()
                    .appendQueryParameter(QUERY_PARAM, queryString)
                    .appendQueryParameter(MAX_RESULTS, "10")
                    .appendQueryParameter(PRINT_TYPE, "books")
                    .build();
            URL requestURL = new URL(builtURI.toString());
            urlConnection = (HttpURLConnection) requestURL.openConnection();
            urlConnection.setRequestMethod("GET");
            urlConnection.connect();
            InputStream inputStream = urlConnection.getInputStream();
            reader = new BufferedReader(new InputStreamReader(inputStream));
            StringBuilder builder = new StringBuilder();
            String line;
            while ((line = reader.readLine()) != null) {
                builder.append(line);
                builder.append("\n");
            }
            if (builder.length() == 0) {
                return null;
            }
            bookJSONString = builder.toString();
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            if (urlConnection != null) {
                urlConnection.disconnect();
            }
            if (reader != null) {
                try {
                    reader.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
        Log.d(LOG_TAG, bookJSONString);
        return bookJSONString;
    }
							</pre>
							</p>
							<p>
							In Android Manifest.xml, coding:
								<pre>
<mark>Before &lt;application&gt;</mark>
&lt;uses-permission android:name="android.permission.INTERNET" /&gt;
&lt;uses-permission 
       android:name="android.permission.ACCESS_NETWORK_STATE" /&gt;
								</pre>
							</p>
						</p>
					</div>
					<div class="box">
						<h3>AsyncTaskLoader</h3>
						<p>
							AsyncTask can't update UI if configuration change (rotate device) occurs while background task is running.
							AsyncTaskLoader can solve it, but if the background task is likely to finish before any configuration changes occur,
							AsynTask is sufficient. 
							<br>Create BookLoader java, coding:
							<pre>
<mark>extends superclass</mark>
extends AsyncTaskLoader&lt;String&gt;

<mark>loadInBackground similar to doInBackground</mark>
private String mQueryString;

BookLoader(Context context, String queryString) {
   super(context);
   mQueryString = queryString;
}

@Nullable
@Override
public String loadInBackground() {
   return NetworkUtils.getBookInfo(mQueryString);;
}

@Override
protected void onStartLoading() {
   super.onStartLoading();
}
							</pre>
							<p>
							In main Activity, coding:
							<pre>
<mark>implement interface</mark>
implements LoaderManager.LoaderCallbacks&lt;String&gt;

<mark>In onCreateLoader, get query string and pass the string to BookLoader for AsynTaskLoader</mark>
<mark>onLoadFinished like onPostExecute</mark>
@NonNull
@Override
public Loader onCreateLoader(int id, @Nullable Bundle args) {
   String queryString = "";

   if (args != null) {
       queryString = args.getString("queryString");
   }

   return new BookLoader(this, queryString);
}

@Override
public void onLoadFinished(@NonNull Loader&lt;String&gt; loader, String data) {
//copy onPostExecute code to here & remove get() & replace the JSONObject constructor
}

@Override
public void onLoaderReset(@NonNull Loader&lt;String&gt; loader) {

}

<mark>Replace new FetchBook with coding, add key/values pair to pass query string</mark>
Bundle queryBundle = new Bundle();
queryBundle.putString("queryString", queryString);
getSupportLoaderManager().restartLoader(0, queryBundle, this);

<mark>Replace JSONObject constructor with coding</mark>
JSONObject jsonObject = new JSONObject(data);

<mark>In onCreate()</mark>
if(getSupportLoaderManager().getLoader(0)!=null){
   getSupportLoaderManager().initLoader(0,null,this);
}
							</pre>
							</p>
						</p>
					</div>
					<div class="box">
						<h3>Broadcast receiver</h3>
						<p>
							Broadcast receivers can receive broadcasts sent by the system or by apps (fundamental).
							<br> File > New > Other > Broadcast Receiver, create CustomReceiver, coding:
							<pre>
<mark>Extends superclass</mark>
extends BroadcastReceiver

<mark>Receiver intercepts broadcast that registered for, Intent is then delivered to 
receiver's onReceive(). Display different toast message for each action 
registered for.</mark>
<mark>Note: define constant of custom broadcast action str for sender and receiver (Main activity &
CustomReceiver) as the broadcast is local broadcast (send to receiver that in same app as sender &
data not shared with other Android app (data secured))</mark>
private static final String ACTION_CUSTOM_BROADCAST =
            BuildConfig.APPLICATION_ID + ".ACTION_CUSTOM_BROADCAST";
			
    @Override
    public void onReceive(Context context, Intent intent) {
        String intentAction = intent.getAction();
        if (intentAction != null) {
            String toastMessage = "unknown intent action";
            switch (intentAction){
                case Intent.ACTION_POWER_CONNECTED:
                    toastMessage = "Power connected!";
                    break;
                case Intent.ACTION_POWER_DISCONNECTED:
                    toastMessage = "Power disconnected!";
                    break;
                case ACTION_CUSTOM_BROADCAST:
                    toastMessage = "Custom Broadcast Received";
                    break;
            }
            Toast.makeText(context, toastMessage, Toast.LENGTH_SHORT).show();
            //Display the toast.
        }

    }
							</pre>
							<p>
							In main Activity, coding:
							<pre>
private CustomReceiver mReceiver = new CustomReceiver();
private static final String ACTION_CUSTOM_BROADCAST =
        BuildConfig.APPLICATION_ID + ".ACTION_CUSTOM_BROADCAST";
		
<mark>In onCreate() | intent filters specify types of intents a component can receive
, filter out incoming intents based on action and category, then register the receiver</mark>
<mark>For local broadcast, use local broadcast manager to register receiver and create intent
& send broadcast if user click on button</mark>
<mark>In onDestroy() must unregister receiver to save sys resource</mark>
IntentFilter filter = new IntentFilter();
        filter.addAction(Intent.ACTION_POWER_DISCONNECTED);
        filter.addAction(Intent.ACTION_POWER_CONNECTED);
        this.registerReceiver(mReceiver, filter);
        LocalBroadcastManager.getInstance(this)
                .registerReceiver(mReceiver,
                        new IntentFilter(ACTION_CUSTOM_BROADCAST));
						
 @Override
    protected void onDestroy() {
        //Unregister the receiver
        this.unregisterReceiver(mReceiver);
        super.onDestroy();
        LocalBroadcastManager.getInstance(this)
                .unregisterReceiver(mReceiver);
    }

    public void sendCustomBroadcast(View view) {
        Intent customBroadcastIntent = new Intent(ACTION_CUSTOM_BROADCAST);
        LocalBroadcastManager.getInstance(this).sendBroadcast(customBroadcastIntent);

    }
							</pre>
							</p>
						</p>
					</div>
				</div>
				<div class = "parentBox">
					<h2>Firebase Database</h2>
					<div class = "box">
						<h3>Writing operation</h3>
						<p>
							Create Artist.java & Track.java
							<br>In main Activity.java, coding:
							<pre>
public static final String ARTIST_NAME = "net.simplifiedcoding.firebasedatabaseexample.artistname";
public static final String ARTIST_ID = "net.simplifiedcoding.firebasedatabaseexample.artistid";
List&lt;Artist&gt; artists;
DatabaseReference databaseArtists;

<mark>In onCreate() | Note: As data stored in JSON tree format, getReference() create ref of artists path 
(like dir) to access all artists stored in the path. If want to access everything, x pass anything to  
create ref of root of tree (like root dir)</mark>
databaseArtists = FirebaseDatabase.getInstance().getReference("artists");
artists = new ArrayList&lt;&gt;();
buttonAddArtist.setOnClickListener(new View.OnClickListener() {
    @Override
    public void onClick(View view) {
        addArtist();
    }
});

<mark>addArtist() | Note: get Artist attribute from view, if x empty > get unique id from
database ref with the attribute to create Artist object, setValue() to save object in database</mark>
private void addArtist() {
        String name = editTextName.getText().toString().trim();
        String genre = spinnerGenre.getSelectedItem().toString();
 
        //checking if the value is provided
        if (!TextUtils.isEmpty(name)) {
            String id = databaseArtists.push().getKey();
            Artist artist = new Artist(id, name, genre);
            databaseArtists.child(id).setValue(artist);
            //setting edittext to blank again
            editTextName.setText("");
            Toast.makeText(this, "Artist added", Toast.LENGTH_LONG).show();
        } else {
            Toast.makeText(this, "Please enter a name", Toast.LENGTH_LONG).show();
        }
    }
							</pre>
						</p>
					</div>
					<div class = "box">
						<h3>Reading Operation</h3>
						<p>
							Create ArtistList class (adapter class), coding:
							<pre>
<mark>extends superclass</mark>
extends ArrayAdapter&lt;Artist&gt;

<mark>Get the activity context, get the item layout and collection of artists</mark>
public ArtistList(Activity context, List&lt;Artist&gt; artists) {
        super(context, R.layout.layout_artist_list, artists);
        this.context = context;
        this.artists = artists;
    }

<mark>binding artists attribute with the view and return the view that inflated</mark>
@Override
    public View getView(int position, View convertView, ViewGroup parent) {
        LayoutInflater inflater = context.getLayoutInflater();
        View listViewItem = inflater.inflate(R.layout.layout_artist_list, null, true);
 
        TextView textViewName = (TextView) listViewItem.findViewById(R.id.textViewName);
        TextView textViewGenre = (TextView) listViewItem.findViewById(R.id.textViewGenre);
 
        Artist artist = artists.get(position);
        textViewName.setText(artist.getArtistName());
        textViewGenre.setText(artist.getArtistGenre());
 
        return listViewItem;
    }
							</pre>
							<p>
							In Main Activity, coding:
							</p>
							<pre>
<mark>in onStart() | Note: attach ValueEventListener (followed with onDataChange & onCancelled) to 
ref to read data, onDataChange will clear previous List, loop to getValue (data), add to List, 
create adapter and attach adapter to listView (like Recycler view), onDataChange() being called 
on any data change (add Artist, it auto add inside listView)</mark>
super.onStart();
        databaseArtists.addValueEventListener(new ValueEventListener() {
            @Override
            public void onDataChange(DataSnapshot dataSnapshot) {
                artists.clear();
                for (DataSnapshot postSnapshot : dataSnapshot.getChildren()) {
                    Artist artist = postSnapshot.getValue(Artist.class);
                    artists.add(artist);
                }
                
                ArtistList artistAdapter = new ArtistList(MainActivity.this, artists);
                listViewArtists.setAdapter(artistAdapter);
            }
 
            @Override
            public void onCancelled(DatabaseError databaseError) {
 
            }
        });
							</pre>
						</p>
					</div>
					<div class = "box">
						<h3>Update operation</h3>
						<p>
							In main Activity, coding:
							<pre>
<mark>Get specified artist using unique id, create update ver of Artist object, override with setValue()</mark>
private boolean updateArtist(String id, String name, String genre) {
        DatabaseReference dR = FirebaseDatabase.getInstance().getReference("artists").child(id);
        Artist artist = new Artist(id, name, genre);
        dR.setValue(artist);
        Toast.makeText(getApplicationContext(), "Artist Updated", Toast.LENGTH_LONG).show();
        return true;
    }
							</pre>
						</p>
				</div>
					<div class = "box">
						<h3>Delete operation</h3>
						<p>
							In main Activity, coding: 
							<pre>
<mark>Similar to update operation, just setValue() to removeValue()</mark>
private boolean deleteArtist(String id) {
        DatabaseReference dR = FirebaseDatabase.getInstance().getReference("artists").child(id);
        dR.removeValue();
        DatabaseReference drTracks = FirebaseDatabase.getInstance().getReference("tracks").child(id);
        drTracks.removeValue();
        Toast.makeText(getApplicationContext(), "Artist Deleted", Toast.LENGTH_LONG).show();
 
        return true;
    }
							</pre>
						</p>
					</div>
				</div>
			</div>
			<script>
				var box = document.getElementsByClassName("box");
				var header = document.getElementsByTagName("H3");
				for (var i = 0; i < box.length; i++){
					header[i].setAttribute("id",i);
					header[i].setAttribute("onclick","descDisplay(this.id)");

					}
				function descDisplay(x){
					var child = box[x].children;
					child[0].style.color = "black";
					for (var j = 1; j < child.length; j++){
						//must use if (display == block instead of none) due to css display = none , DOM can't really get value none from css 
						//so if using none will result in clicking 2 times to display block for the first time.
						if (child[j].style.display == "block"){
							child[j].style.display = "none";
						}
						else{
							child[j].style.display = "block";
						}
					}
				}

			</script>
			<footer>
				<small>
					Copyright reserved &copy; Android Studio 2018<br>Created by Soo Meng Kit 
				</small>
			</footer>
		</body>
	</html>